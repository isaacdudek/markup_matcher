# MarkupMatcher

[![Circle CI](https://circleci.com/gh/isaacdudek/markup_matcher.png?style=badge&circle-token=6b4dd523d59385c4c0077a5032a7d482fb6d0846)](https://circleci.com/gh/isaacdudek/markup_matcher)

MarkupMatcher provides an RSpec matcher that compares snippets of HTML/XML markup. It can compare for perfect equality (allowing no unmatched elements or attributes) or just partial equivalency (allowing unmatched elements and/or attributes).

## Rationale

MarkupMatcher was created to easily compare the markup generated by back-end frameworks (e.g., [Ruby on Rails](http://rubyonrails.org/)) to the markup required by front-end frameworks (e.g., [Bootstrap](http://getbootstrap.com/)). A detailed example of how this is accomplished can be seen in the [walkthrough](#walkthrough).

Demanding perfect markup equality is impractical given the different goals and requirements of each framework. Take forms, for example. The back-end has to handle things like generating hidden inputs for CSRF tokens and naming inputs for compatibility with submission endpoints. Whereas the front-end is primarily concerned with providing semantic markup and applying classes with which to attach styles.

Ensuring the back-end generates markup that complies with the front-end's requirements isn't easy, but it's essential to preventing regressions whereby an innocuous back-end change breaks the front-end rendering. This can be achieved by writing dozens (if not hundreds) of tedious markup tests, or by writing just a few high-level tests using MarkupMatcher.

## Installation

Add this line to your application's Gemfile:

```ruby
gem 'markup_matcher', group: :test
```

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install markup_matcher

## Usage

MarkupMatcher provides an RSpec matcher called `match_markup` which is automatically included in all example groups and can be called as follows:

```ruby
it 'should generate compatible markup' do
  expect('<p>Paragraph</p>').to match_markup('<p>Paragraph</p>')
end
```

For multiline markup, use here documents:

```ruby
it 'should generate compatible markup' do
  expect(
    <<-HTML
      <h1>Heading</h1>
      <p>Paragraph</p>
    HTML
  ).to match_markup(
    <<-HTML
      <h1>Heading</h1>
      <p>Paragraph</p>
    HTML
  )
end
```

MarkupMatcher will automatically collapse all runs of whitespace to a single space before performing its comparison (which also addresses any whitespace issues introduced by using here documents).

### Options

The `match_markup` matcher accepts a number of options which can be passed as follows:

```ruby
it 'should generate compatible markup' do
  expect(
    <<-HTML
      <h1 class="heading">Heading</h1>
      <p class="paragraph">Paragraph</p>
    HTML
  ).to match_markup(
    <<-HTML
      <h1>Heading</h1>
      <p>Paragraph</p>
    HTML
  ).with_options(allow_extra_attributes: true)
end
```

The available options are:

- `allow_extra_attributes` - Allow all elements in the test markup to have attributes not present in the corresponding elements in the target markup.

- `allow_missing_attributes` - Allow all elements in the target markup to have attributes not present in the corresponding elements in the test markup.

- `allow_extra_children` - Allow all elements in the test markup to have child elements not present in the corresponding elements in the target markup.

- `allow_missing_children` - Allow all elements in the target markup to have child elements not present in the corresponding elements in the test markup.

#### Defaults

To simplify the most common use case, the `allow_extra_attributes` and `allow_extra_children` options are set to `true` by default. However, they can be easily disabled on a per-example basis by setting them to `false`:

```ruby
it 'should generate compatible markup' do
  expect(
    <<-HTML
      <h1>Heading</h1>
      <p>Paragraph</p>
    HTML
  ).to match_markup(
    <<-HTML
      <h1>Heading</h1>
      <p>Paragraph</p>
    HTML
  ).with_options(allow_extra_attributes: false, allow_extra_children: false)
end
```

## Walkthrough

To see how easy it is to set up valuable, real-world tests using MarkupMatcher, consider the following scenario.

You have an application that uses [Ruby on Rails](http://rubyonrails.org/) on the back-end and [Bootstrap](http://getbootstrap.com/) on the front-end. You use [Simple Form](https://github.com/plataformatec/simple_form) to generate form markup. Simple Form ships with [Bootstrap support](https://github.com/plataformatec/simple_form#bootstrap), but what if you want to ensure that [Simple Form's Bootstrap configuration](https://github.com/plataformatec/simple_form/blob/master/lib/generators/simple_form/templates/config/initializers/simple_form_bootstrap.rb) works now and in the future, across upgrades of either Bootstrap or Simple Form, itself?

First, set up the test:

```ruby
it 'should match the markup in "Basic example"' do
  expect('').to match_markup(
    <<-HTML
    HTML
  )
end
```

Next, paste in the form markup from [Bootstrap's "Basic example" documentation](http://getbootstrap.com/css/#forms-example):

```ruby
it 'should match the markup in "Basic example"' do
  expect('').to match_markup(
    <<-HTML
      <form role="form">
        <div class="form-group">
          <label for="exampleInputEmail1">Email address</label>
          <input type="email" class="form-control" id="exampleInputEmail1" placeholder="Enter email">
        </div>
        <div class="form-group">
          <label for="exampleInputPassword1">Password</label>
          <input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password">
        </div>
        <div class="form-group">
          <label for="exampleInputFile">File input</label>
          <input type="file" id="exampleInputFile">
          <p class="help-block">Example block-level help text here.</p>
        </div>
        <div class="checkbox">
          <label>
            <input type="checkbox"> Check me out
          </label>
        </div>
        <button type="submit" class="btn btn-default">Submit</button>
      </form>
    HTML
  )
end
```

Then, run the test and see that it fails with an unexpected warning:

```
WARNING! Differences were detected after parsing the expected markup.
The expected markup must be well-formed XML to avoid deformation during parsing.
Comparison to the actual markup was not performed.

...
```

The warning indicates that Bootstrap's example markup did not parse correctly, making comparison to any test markup irrelevant. MarkupMatcher requires all expected markup to be valid XML in order to perform its comparisons. This is easy to fix, however. You just need to add slashes to any [void elements](http://www.w3.org/TR/html5/syntax.html#void-elements) (in this case, the `input` tags):

```ruby
it 'should match the markup in "Basic example"' do
  expect('').to match_markup(
    <<-HTML
      <form role="form">
        <div class="form-group">
          <label for="exampleInputEmail1">Email address</label>
          <input type="email" class="form-control" id="exampleInputEmail1" placeholder="Enter email"/>
        </div>
        <div class="form-group">
          <label for="exampleInputPassword1">Password</label>
          <input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"/>
        </div>
        <div class="form-group">
          <label for="exampleInputFile">File input</label>
          <input type="file" id="exampleInputFile"/>
          <p class="help-block">Example block-level help text here.</p>
        </div>
        <div class="checkbox">
          <label>
            <input type="checkbox"/> Check me out
          </label>
        </div>
        <button type="submit" class="btn btn-default">Submit</button>
      </form>
    HTML
  )
end
```

Finally, generate the correct markup to make the test pass:

```ruby
it 'should match the markup in "Basic example"' do
  expect(
    render(
      <<-ERB
        <%= simple_form_for @model, html: {role: 'form'}, url: '#' do |f| %>
          <%= f.input :email, input_html: {id: 'exampleInputEmail1'}, label: 'Email address', placeholder: 'Enter email' %>
          <%= f.input :password, input_html: {id: 'exampleInputPassword1'}, label: 'Password', placeholder: 'Password' %>
          <%= f.input :file, as: :file, hint: 'Example block-level help text here.', input_html: {id: 'exampleInputFile'}, label: 'File input' %>
          <%= f.input :boolean, as: :boolean, label: 'Check me out', wrapper: false %>
          <%= f.button :button, 'Submit' %>
        <% end %>
      ERB
    )
  ).to match_markup(
    <<-HTML
      <form role="form">
        <div class="form-group">
          <label for="exampleInputEmail1">Email address</label>
          <input type="email" class="form-control" id="exampleInputEmail1" placeholder="Enter email"/>
        </div>
        <div class="form-group">
          <label for="exampleInputPassword1">Password</label>
          <input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"/>
        </div>
        <div class="form-group">
          <label for="exampleInputFile">File input</label>
          <input type="file" id="exampleInputFile"/>
          <p class="help-block">Example block-level help text here.</p>
        </div>
        <div class="checkbox">
          <label>
            <input type="checkbox"/> Check me out
          </label>
        </div>
        <button type="submit" class="btn btn-default">Submit</button>
      </form>
    HTML
  )
end
```

Note that this test uses a **theoretical** (in other words, nonexistent) method called `render` to convert the snippet of ERB to HTML for comparison. The exact mechanism you use to generate your test markup will be specific to what you're testing and how you're testing it. Look into RSpec's Rails integration&mdash;specifically at [View specs](https://relishapp.com/rspec/rspec-rails/v/3-1/docs/view-specs) and [Helper specs](https://relishapp.com/rspec/rspec-rails/v/3-1/docs/helper-specs)&mdash;for ideas on structuring tests that will use MarkupMatcher.

Also, note that, while the Simple Form test markup includes many customizations (manually setting `id`, `label`, `placeholder`, and other options), Simple Form can, of course, handle these automatically via its [I18n integration](https://github.com/plataformatec/simple_form#i18n). Two points on this:

1. For this test, it's easier to simply inline the values rather than putting them in an external translation file that needs to be loaded during the test run.

2. It's better to adjust your Simple Form input rather than your Bootstrap output because then you can easily paste new Bootstrap markup into your test when upgrading Bootstrap in the future.

### Unmatched Value

The real value of MarkupMatcher is apparent when you consider what components of the markup are **irrelevant** to your test. Here is the actual HTML generated by the ERB snippet above:

```html
<form role="form" novalidate="novalidate" class="simple_form new_model" id="new_model" enctype="multipart/form-data" action="#" accept-charset="UTF-8" method="post">
  <input name="utf8" type="hidden" value="&#x2713;">
  <div class="form-group">
    <label for="exampleInputEmail1" class="control-label">Email address</label>
    <input id="exampleInputEmail1" placeholder="Enter email" type="email" class="form-control" name="model[email]">
  </div>
  <div class="form-group">
    <label for="exampleInputPassword1" class="control-label">Password</label>
    <input id="exampleInputPassword1" placeholder="Password" class="form-control" type="password" name="model[password]">
  </div>
  <div class="form-group">
    <label for="exampleInputFile" class="control-label">File input</label>
    <input id="exampleInputFile" class="form-control" type="file" name="model[file]">
    <p class="help-block">Example block-level help text here.</p>
  </div>
  <div class="checkbox">
    <input value="0" type="hidden" name="model[boolean]">
    <label class="" for="model_boolean">
      <input type="checkbox" value="1" name="model[boolean]" id="model_boolean"> Check me out
    </label>
  </div>
  <button name="button" type="submit" class="btn btn-default">Submit</button>
</form>
```

Look at all of the markup Simple Form generates that is irrelevant to Bootstrap:

![](https://github.com/isaacdudek/markup_matcher/blob/3f647ffdd4bab84dbdde91f050d4bddb16e29201/unmatched-value.png)

MarkupMatcher, specifically when operating with its [defaults](#defaults), allows you verify that the test markup has everything that the target markup requires, while ignoring everything extra that the test markup needs to include to fulfill its purpose.

## Contributing

1. Fork it (https://github.com/isaacdudek/markup_matcher/fork)
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create a new Pull Request
